<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surprise</title>
    <!-- Use Tailwind CSS for modern styling -->
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to bottom, #000000, #333333);
            overflow: hidden;
            font-family: 'Dancing Script', cursive;
            background:black;
        }
        #canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #text-container {
            position: absolute;
            text-align: center;
            color: #ffffff;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        #main-text {
            font-weight: 700;
            text-shadow: 0 0 8px #ffffff, 0 0 16px #ff0000;
            margin-bottom: 8px;
        }
        #poem {
            line-height: 1.3;
            text-shadow: 0 0 8px #ffffff, 0 0 16px #555454;
        }
        .start-button {
            z-index: 20;
            padding: 1rem 2rem;
            background-color: #dc2626; /* bg-red-600 */
            color: #ffffff; /* text-white */
            font-weight: 700; /* font-bold */
            font-size: 1.125rem; /* text-lg */
            border-radius: 9999px; /* rounded-full */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
        }
        .start_menu{
            justify-content: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h2{
            margin:2% 0%;
            padding:1% 0%;
            color: white;
            margin-top: 10px;
            font-family: 'Arial', sans-serif;
        }
        .start_menu h2 span{
            color: #dc2626;
        }
        .start-button:hover {
            background-color: #b91c1c; /* hover:bg-red-700 */
        }
        .start-button:focus {
            outline: none; /* focus:outline-none */
            box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.5); /* focus:ring-4 focus:ring-red-500 focus:ring-opacity-50 */
        }
        @media (max-width: 600px) {
            #text-container {
                font-size: 1.5em;
            }
        }
        @media (min-width: 601px) {
            #text-container {
                font-size: 1.2em;
            }
            #poem {
                line-height: 1;
                text-shadow: 0 0 8px #ffffff, 0 0 16px #ff0000;
            }
        }
    </style>
</head>
<body>
    <div class="start_menu" id="startMenu">
        <button id="startBtn" class="start-button">Click to view</button>
        <h2>Developed by <span>Tris</span> Tech Hub</h2>
    </div>
    
    <canvas id="canvas"></canvas>
    <div id="text-container">
        <div id="main-text"></div>
        <div id="poem"></div>
    </div>
    
    <audio id="background-music" loop preload="auto">
        <!-- Add the URL to your romantic music file here. -->
        <source src="back2.mp3" type="audio/mpeg">
    </audio>

    <script>
        const startBtn = document.getElementById('startBtn');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const textContainer = document.getElementById('text-container');
        const mainText = document.getElementById('main-text');
        const poemText = document.getElementById('poem');
        const audio = document.getElementById('background-music');

        let canvasWidth = window.innerWidth;
        let canvasHeight = window.innerHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // --- Heart Animation ---
        const heartPoints = [];
        let animationStart = null;
        let animationState = 'drawing';
        const drawDuration = 1500; // 1.5s
        const typeDuration = 4500; // 4.5s
        const totalDuration = drawDuration + typeDuration; // 6s

        function generateHeartPoints() {
            heartPoints.length = 0;
            const currentScale = Math.min(canvasWidth * 0.95, canvasHeight * 0.75) / 2;
            const currentCenterX = canvasWidth / 2;
            const currentCenterY = canvasHeight / 2;
            for (let t = 0; t <= 2 * Math.PI; t += 0.02) {
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = - (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                heartPoints.push({
                    x: currentCenterX + x * currentScale / 16,
                    y: currentCenterY + y * currentScale / 16
                });
            }
        }

        // --- Offscreen Canvas for Performance ---
        let offscreenCanvas = document.createElement('canvas');
        let offscreenCtx = offscreenCanvas.getContext('2d');
        offscreenCanvas.width = canvas.width;
        offscreenCanvas.height = canvasHeight;

        function drawCompleteHeart() {
            offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            offscreenCtx.beginPath();
            offscreenCtx.moveTo(heartPoints[0].x, heartPoints[0].y);
            for (let i = 1; i < heartPoints.length; i++) {
                offscreenCtx.lineTo(heartPoints[i].x, heartPoints[i].y);
            }
            offscreenCtx.strokeStyle = '#ff0000';
            offscreenCtx.lineWidth = 2;
            offscreenCtx.shadowColor = '#ff0000';
            offscreenCtx.shadowBlur = 15;
            offscreenCtx.stroke();
            offscreenCtx.closePath();
        }

        // --- Stars Animation ---
        const stars = [];
        const numStars = 20;
        for (let i = 0; i < numStars; i++) {
            stars.push({
                x: Math.random() * canvasWidth,
                y: Math.random() * canvasHeight,
                radius: Math.random() * 1.2 + 0.5,
                alpha: 0,
                dAlpha: (Math.random() * 0.015 + 0.01) * (Math.random() > 0.5 ? 1 : -1),
                phase: Math.random() * Math.PI * 2
            });
        }

        function drawStars() {
            stars.forEach(star => {
                star.alpha += star.dAlpha;
                if (star.alpha > 0.6 || star.alpha < 0) star.dAlpha *= -1;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                ctx.fill();
            });
        }

        // --- Typewriter Effect ---
       const mainTextContent = "I Love you Aula";
        const poemLines = [
            "I miss you more than silence misses sound,",
            "Serieux Choux ,I miss you physically and emotionally.",
            "This feeling of missing u is 10x of me dealing with a billion bugs in my code.",
            "Today nashatse kubikubwira gusa I didn't get the chance to do so",
            "Choux, what I want is that basi lets communicate like before",
            "Kuko I think this poor communication is the root of this feeling of missing you",
            "And for once,I am scared that this communication gap may harm our relationship",
            "From your Psycho, with love <3"
        ];
        let currentMainTextIndex = 0;
        let currentPoemLine = 0;
        let currentPoemChar = 0;

        function typeText(timestamp) {
            const mainTextDuration = 1200; // 1.2s for main text
            const poemDuration = 3300; // 3.3s for poem
            const totalTypeDuration = mainTextDuration + poemDuration;
            const typeElapsed = timestamp - animationStart - drawDuration;

            if (typeElapsed < mainTextDuration) {
                const charTime = mainTextDuration / mainTextContent.length;
                const charsToShow = Math.min(Math.floor(typeElapsed / charTime), mainTextContent.length);
                if (charsToShow > currentMainTextIndex) {
                    mainText.textContent = mainTextContent.slice(0, charsToShow);
                    currentMainTextIndex = charsToShow;
                }
            } else if (typeElapsed < totalTypeDuration) {
                const poemElapsed = typeElapsed - mainTextDuration;
                const lineTime = poemDuration / poemLines.length;
                const currentLine = Math.min(Math.floor(poemElapsed / lineTime), poemLines.length - 1);
                if (currentLine > currentPoemLine) {
                    currentPoemLine = currentLine;
                    currentPoemChar = 0;
                    poemText.innerHTML = poemLines.slice(0, currentLine).join('<br>');
                }
                const charTime = lineTime / poemLines[currentLine].length;
                const charsToShow = Math.min(Math.floor((poemElapsed - currentLine * lineTime) / charTime), poemLines[currentLine].length);
                if (charsToShow > currentPoemChar) {
                    currentPoemChar = charsToShow;
                    poemText.innerHTML = poemLines.slice(0, currentLine).join('<br>') + (currentLine < poemLines.length ? '<br>' + poemLines[currentLine].slice(0, charsToShow) : '');
                }
            } else {
                mainText.textContent = mainTextContent;
                poemText.innerHTML = poemLines.join('<br>');
            }
        }

        // --- Animation Loop Functions ---
        function animate(timestamp) {
            if (!animationStart) animationStart = timestamp;
            const elapsed = timestamp - animationStart;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars();
            if (elapsed < drawDuration) {
                animationState = 'drawing';
                const progress = elapsed / drawDuration;
                const endPoint = Math.floor(progress * heartPoints.length);
                ctx.beginPath();
                ctx.moveTo(heartPoints[0].x, heartPoints[0].y);
                for (let i = 1; i <= endPoint && i < heartPoints.length; i++) {
                    ctx.lineTo(heartPoints[i].x, heartPoints[i].y);
                }
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.stroke();
                mainText.textContent = '';
                poemText.innerHTML = '';
                requestAnimationFrame(animate);
            } else if (elapsed < totalDuration) {
                animationState = 'typing';
                ctx.drawImage(offscreenCanvas, 0, 0);
                typeText(timestamp);
                requestAnimationFrame(animate);
            } else {
                animationState = 'showing';
                ctx.drawImage(offscreenCanvas, 0, 0);
                mainText.textContent = mainTextContent;
                poemText.innerHTML = poemLines.join('<br>');
                requestAnimationFrame(animateStars);
            }
        }

        function animateStars(timestamp) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars();

            // Heart Pulse Animation
            const pulse = 1 + 0.05 * (1 + Math.sin(timestamp / 500)) / 2;
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(pulse, pulse);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);
            ctx.drawImage(offscreenCanvas, 0, 0);
            ctx.restore();

            requestAnimationFrame(animateStars);
        }

        // --- Event Listeners and Initial Setup ---
        startBtn.addEventListener('click', () => {
            // First, start the animation.
            document.getElementById('startMenu').style.display = 'none';
            startBtn.style.display = 'none';
            animationStart = null; // Reset animation timer
            requestAnimationFrame(animate);

            // Then, attempt to play the audio.
            audio.play()
                .then(() => {
                    console.log('Audio playback started successfully.');
                })
                .catch(e => {
                    console.error('Audio playback failed. This is expected if the URL is invalid or the browser prevents autoplay:', e);
                });
        });

        function handleResize() {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            offscreenCanvas.width = canvasWidth;
            offscreenCanvas.height = canvasHeight;
            generateHeartPoints();
            drawCompleteHeart();
            stars.forEach(star => {
                star.x = Math.random() * canvasWidth;
                star.y = Math.random() * canvasHeight;
            });
            const scale = Math.min(canvasWidth, canvasHeight);
            mainText.style.fontSize = `${Math.max(12, scale / 15)}px`;
            poemText.style.fontSize = `${Math.max(10, scale / 25)}px`;
            if (animationState === 'showing') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawStars();
                ctx.drawImage(offscreenCanvas, 0, 0);
            }
        }

        window.addEventListener('resize', handleResize);
        handleResize(); // Initial call to set sizes
    </script>
</body>
</html>






